#if os(macOS)
import SystemConfiguration
#endif
// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(askar_uniffiFFI)
    import askar_uniffiFFI
#endif

private extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_askar_uniffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_askar_uniffi_rustbuffer_free(self, $0) }
    }
}

private extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

private extension Data {
    init(rustBuffer: RustBuffer) {
        // TODO: This copies the buffer. Can we read directly from a
        // Rust buffer?
        self.init(bytes: rustBuffer.data!, count: Int(rustBuffer.len))
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

private func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
private func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset ..< reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value) { reader.data.copyBytes(to: $0, from: range) }
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
private func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> [UInt8] {
    let range = reader.offset ..< (reader.offset + count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer { buffer in
        reader.data.copyBytes(to: buffer, from: range)
    }
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
private func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return try Float(bitPattern: readInt(&reader))
}

// Reads a float at the current offset.
private func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return try Double(bitPattern: readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
private func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

private func createWriter() -> [UInt8] {
    return []
}

private func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
private func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

private func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

private func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous go the Rust trait of the same name.
private protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
private protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType {}

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
private protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
        var writer = createWriter()
        write(value, into: &writer)
        return RustBuffer(bytes: writer)
    }
}

// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
private enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

private let CALL_SUCCESS: Int8 = 0
private let CALL_ERROR: Int8 = 1
private let CALL_PANIC: Int8 = 2
private let CALL_CANCELLED: Int8 = 3

private extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: nil)
}

private func rustCallWithError<T>(
    _ errorHandler: @escaping (RustBuffer) throws -> Error,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T
) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> Error)?
) throws {
    switch callStatus.code {
    case CALL_SUCCESS:
        return

    case CALL_ERROR:
        if let errorHandler = errorHandler {
            throw try errorHandler(callStatus.errorBuf)
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.unexpectedRustCallError
        }

    case CALL_PANIC:
        // When the rust code sees a panic, it tries to construct a RustBuffer
        // with the message.  But if that code panics, then it just sends back
        // an empty buffer.
        if callStatus.errorBuf.len > 0 {
            throw try UniffiInternalError.rustPanic(FfiConverterString.lift(callStatus.errorBuf))
        } else {
            callStatus.errorBuf.deallocate()
            throw UniffiInternalError.rustPanic("Rust panic")
        }

    case CALL_CANCELLED:
        throw CancellationError()

    default:
        throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

// Public interface members begin here.

private struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterBool: FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

private struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return try String(bytes: readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

private struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return try Data(readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

public protocol AskarCryptoProtocol {
    func boxOpen(receiverKey: AskarLocalKey, senderKey: AskarLocalKey, message: Data, nonce: Data) throws -> Data
    func boxSeal(receiverKey: AskarLocalKey, message: Data) throws -> Data
    func boxSealOpen(receiverKey: AskarLocalKey, ciphertext: Data) throws -> Data
    func cryptoBox(receiverKey: AskarLocalKey, senderKey: AskarLocalKey, message: Data, nonce: Data) throws -> Data
    func randomNonce() throws -> Data
}

public class AskarCrypto: AskarCryptoProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_askar_uniffi_fn_constructor_askarcrypto_new($0)
        })
    }

    deinit {
        try! rustCall { uniffi_askar_uniffi_fn_free_askarcrypto(pointer, $0) }
    }

    public func boxOpen(receiverKey: AskarLocalKey, senderKey: AskarLocalKey, message: Data, nonce: Data) throws -> Data {
        return try FfiConverterData.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarcrypto_box_open(self.pointer,
                                                                   FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                   FfiConverterTypeAskarLocalKey.lower(senderKey),
                                                                   FfiConverterData.lower(message),
                                                                   FfiConverterData.lower(nonce), $0)
            }
        )
    }

    public func boxSeal(receiverKey: AskarLocalKey, message: Data) throws -> Data {
        return try FfiConverterData.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarcrypto_box_seal(self.pointer,
                                                                   FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                   FfiConverterData.lower(message), $0)
            }
        )
    }

    public func boxSealOpen(receiverKey: AskarLocalKey, ciphertext: Data) throws -> Data {
        return try FfiConverterData.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarcrypto_box_seal_open(self.pointer,
                                                                        FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                        FfiConverterData.lower(ciphertext), $0)
            }
        )
    }

    public func cryptoBox(receiverKey: AskarLocalKey, senderKey: AskarLocalKey, message: Data, nonce: Data) throws -> Data {
        return try FfiConverterData.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarcrypto_crypto_box(self.pointer,
                                                                     FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                     FfiConverterTypeAskarLocalKey.lower(senderKey),
                                                                     FfiConverterData.lower(message),
                                                                     FfiConverterData.lower(nonce), $0)
            }
        )
    }

    public func randomNonce() throws -> Data {
        return try FfiConverterData.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarcrypto_random_nonce(self.pointer, $0)
            }
        )
    }
}

public struct FfiConverterTypeAskarCrypto: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarCrypto

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarCrypto {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarCrypto, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarCrypto {
        return AskarCrypto(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarCrypto) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarCrypto_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarCrypto {
    return try FfiConverterTypeAskarCrypto.lift(pointer)
}

public func FfiConverterTypeAskarCrypto_lower(_ value: AskarCrypto) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarCrypto.lower(value)
}

public protocol AskarEcdh1PUProtocol {
    func decryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: Data, tag: Data?, nonce: Data, aad: Data?) throws -> Data
    func deriveKey(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, ccTag: Data, receive: Bool) throws -> AskarLocalKey
    func encryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, message: Data, nonce: Data?, aad: Data?) throws -> EncryptedBuffer
    func receiverUnwrapKey(wrapAlg: AskarKeyAlg, encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: Data, ccTag: Data, nonce: Data?, tag: Data?) throws -> AskarLocalKey
    func senderWrapKey(wrapAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, cek: AskarLocalKey, ccTag: Data) throws -> EncryptedBuffer
}

public class AskarEcdh1Pu: AskarEcdh1PUProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(algId: String, apu: String, apv: String) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_askar_uniffi_fn_constructor_askarecdh1pu_new(
                FfiConverterString.lower(algId),
                FfiConverterString.lower(apu),
                FfiConverterString.lower(apv), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_askar_uniffi_fn_free_askarecdh1pu(pointer, $0) }
    }

    public func decryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: Data, tag: Data?, nonce: Data, aad: Data?) throws -> Data {
        return try FfiConverterData.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarecdh1pu_decrypt_direct(self.pointer,
                                                                          FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                          FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                          FfiConverterTypeAskarLocalKey.lower(senderKey),
                                                                          FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                          FfiConverterData.lower(ciphertext),
                                                                          FfiConverterOptionData.lower(tag),
                                                                          FfiConverterData.lower(nonce),
                                                                          FfiConverterOptionData.lower(aad), $0)
            }
        )
    }

    public func deriveKey(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, ccTag: Data, receive: Bool) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarecdh1pu_derive_key(self.pointer,
                                                                      FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                      FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                      FfiConverterTypeAskarLocalKey.lower(senderKey),
                                                                      FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                      FfiConverterData.lower(ccTag),
                                                                      FfiConverterBool.lower(receive), $0)
            }
        )
    }

    public func encryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, message: Data, nonce: Data?, aad: Data?) throws -> EncryptedBuffer {
        return try FfiConverterTypeEncryptedBuffer.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarecdh1pu_encrypt_direct(self.pointer,
                                                                          FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                          FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                          FfiConverterTypeAskarLocalKey.lower(senderKey),
                                                                          FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                          FfiConverterData.lower(message),
                                                                          FfiConverterOptionData.lower(nonce),
                                                                          FfiConverterOptionData.lower(aad), $0)
            }
        )
    }

    public func receiverUnwrapKey(wrapAlg: AskarKeyAlg, encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: Data, ccTag: Data, nonce: Data?, tag: Data?) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarecdh1pu_receiver_unwrap_key(self.pointer,
                                                                               FfiConverterTypeAskarKeyAlg.lower(wrapAlg),
                                                                               FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                               FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                               FfiConverterTypeAskarLocalKey.lower(senderKey),
                                                                               FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                               FfiConverterData.lower(ciphertext),
                                                                               FfiConverterData.lower(ccTag),
                                                                               FfiConverterOptionData.lower(nonce),
                                                                               FfiConverterOptionData.lower(tag), $0)
            }
        )
    }

    public func senderWrapKey(wrapAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, senderKey: AskarLocalKey, receiverKey: AskarLocalKey, cek: AskarLocalKey, ccTag: Data) throws -> EncryptedBuffer {
        return try FfiConverterTypeEncryptedBuffer.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarecdh1pu_sender_wrap_key(self.pointer,
                                                                           FfiConverterTypeAskarKeyAlg.lower(wrapAlg),
                                                                           FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                           FfiConverterTypeAskarLocalKey.lower(senderKey),
                                                                           FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                           FfiConverterTypeAskarLocalKey.lower(cek),
                                                                           FfiConverterData.lower(ccTag), $0)
            }
        )
    }
}

public struct FfiConverterTypeAskarEcdh1PU: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarEcdh1Pu

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarEcdh1Pu {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarEcdh1Pu, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEcdh1Pu {
        return AskarEcdh1Pu(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarEcdh1Pu) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarEcdh1PU_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEcdh1Pu {
    return try FfiConverterTypeAskarEcdh1PU.lift(pointer)
}

public func FfiConverterTypeAskarEcdh1PU_lower(_ value: AskarEcdh1Pu) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarEcdh1PU.lower(value)
}

public protocol AskarEcdhEsProtocol {
    func decryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: Data, tag: Data?, nonce: Data, aad: Data?) throws -> Data
    func deriveKey(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, receive: Bool) throws -> AskarLocalKey
    func encryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, message: Data, nonce: Data?, aad: Data?) throws -> EncryptedBuffer
    func receiverUnwrapKey(wrapAlg: AskarKeyAlg, encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: Data, nonce: Data?, tag: Data?) throws -> AskarLocalKey
    func senderWrapKey(wrapAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, cek: AskarLocalKey) throws -> EncryptedBuffer
}

public class AskarEcdhEs: AskarEcdhEsProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init(algId: String, apu: String, apv: String) {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_askar_uniffi_fn_constructor_askarecdhes_new(
                FfiConverterString.lower(algId),
                FfiConverterString.lower(apu),
                FfiConverterString.lower(apv), $0
            )
        })
    }

    deinit {
        try! rustCall { uniffi_askar_uniffi_fn_free_askarecdhes(pointer, $0) }
    }

    public func decryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: Data, tag: Data?, nonce: Data, aad: Data?) throws -> Data {
        return try FfiConverterData.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarecdhes_decrypt_direct(self.pointer,
                                                                         FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                         FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                         FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                         FfiConverterData.lower(ciphertext),
                                                                         FfiConverterOptionData.lower(tag),
                                                                         FfiConverterData.lower(nonce),
                                                                         FfiConverterOptionData.lower(aad), $0)
            }
        )
    }

    public func deriveKey(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, receive: Bool) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarecdhes_derive_key(self.pointer,
                                                                     FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                     FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                     FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                     FfiConverterBool.lower(receive), $0)
            }
        )
    }

    public func encryptDirect(encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, message: Data, nonce: Data?, aad: Data?) throws -> EncryptedBuffer {
        return try FfiConverterTypeEncryptedBuffer.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarecdhes_encrypt_direct(self.pointer,
                                                                         FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                         FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                         FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                         FfiConverterData.lower(message),
                                                                         FfiConverterOptionData.lower(nonce),
                                                                         FfiConverterOptionData.lower(aad), $0)
            }
        )
    }

    public func receiverUnwrapKey(wrapAlg: AskarKeyAlg, encAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, ciphertext: Data, nonce: Data?, tag: Data?) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarecdhes_receiver_unwrap_key(self.pointer,
                                                                              FfiConverterTypeAskarKeyAlg.lower(wrapAlg),
                                                                              FfiConverterTypeAskarKeyAlg.lower(encAlg),
                                                                              FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                              FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                              FfiConverterData.lower(ciphertext),
                                                                              FfiConverterOptionData.lower(nonce),
                                                                              FfiConverterOptionData.lower(tag), $0)
            }
        )
    }

    public func senderWrapKey(wrapAlg: AskarKeyAlg, ephemeralKey: AskarLocalKey, receiverKey: AskarLocalKey, cek: AskarLocalKey) throws -> EncryptedBuffer {
        return try FfiConverterTypeEncryptedBuffer.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarecdhes_sender_wrap_key(self.pointer,
                                                                          FfiConverterTypeAskarKeyAlg.lower(wrapAlg),
                                                                          FfiConverterTypeAskarLocalKey.lower(ephemeralKey),
                                                                          FfiConverterTypeAskarLocalKey.lower(receiverKey),
                                                                          FfiConverterTypeAskarLocalKey.lower(cek), $0)
            }
        )
    }
}

public struct FfiConverterTypeAskarEcdhEs: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarEcdhEs

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarEcdhEs {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarEcdhEs, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEcdhEs {
        return AskarEcdhEs(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarEcdhEs) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarEcdhEs_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEcdhEs {
    return try FfiConverterTypeAskarEcdhEs.lift(pointer)
}

public func FfiConverterTypeAskarEcdhEs_lower(_ value: AskarEcdhEs) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarEcdhEs.lower(value)
}

public protocol AskarEntryProtocol {
    func category() -> String
    func name() -> String
    func tags() -> [String: String]
    func value() -> Data
}

public class AskarEntry: AskarEntryProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_askar_uniffi_fn_free_askarentry(pointer, $0) }
    }

    public func category() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_askar_uniffi_fn_method_askarentry_category(self.pointer, $0)
                }
        )
    }

    public func name() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_askar_uniffi_fn_method_askarentry_name(self.pointer, $0)
                }
        )
    }

    public func tags() -> [String: String] {
        return try! FfiConverterDictionaryStringString.lift(
            try!
                rustCall {
                    uniffi_askar_uniffi_fn_method_askarentry_tags(self.pointer, $0)
                }
        )
    }

    public func value() -> Data {
        return try! FfiConverterData.lift(
            try!
                rustCall {
                    uniffi_askar_uniffi_fn_method_askarentry_value(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeAskarEntry: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarEntry

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarEntry {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarEntry, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEntry {
        return AskarEntry(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarEntry) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarEntry_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarEntry {
    return try FfiConverterTypeAskarEntry.lift(pointer)
}

public func FfiConverterTypeAskarEntry_lower(_ value: AskarEntry) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarEntry.lower(value)
}

public protocol AskarKeyEntryProtocol {
    func algorithm() -> String?
    func isLocal() -> Bool
    func loadLocalKey() throws -> AskarLocalKey
    func metadata() -> String?
    func name() -> String
    func tags() -> [String: String]
}

public class AskarKeyEntry: AskarKeyEntryProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_askar_uniffi_fn_free_askarkeyentry(pointer, $0) }
    }

    public func algorithm() -> String? {
        return try! FfiConverterOptionString.lift(
            try!
                rustCall {
                    uniffi_askar_uniffi_fn_method_askarkeyentry_algorithm(self.pointer, $0)
                }
        )
    }

    public func isLocal() -> Bool {
        return try! FfiConverterBool.lift(
            try!
                rustCall {
                    uniffi_askar_uniffi_fn_method_askarkeyentry_is_local(self.pointer, $0)
                }
        )
    }

    public func loadLocalKey() throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarkeyentry_load_local_key(self.pointer, $0)
            }
        )
    }

    public func metadata() -> String? {
        return try! FfiConverterOptionString.lift(
            try!
                rustCall {
                    uniffi_askar_uniffi_fn_method_askarkeyentry_metadata(self.pointer, $0)
                }
        )
    }

    public func name() -> String {
        return try! FfiConverterString.lift(
            try!
                rustCall {
                    uniffi_askar_uniffi_fn_method_askarkeyentry_name(self.pointer, $0)
                }
        )
    }

    public func tags() -> [String: String] {
        return try! FfiConverterDictionaryStringString.lift(
            try!
                rustCall {
                    uniffi_askar_uniffi_fn_method_askarkeyentry_tags(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeAskarKeyEntry: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarKeyEntry

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarKeyEntry {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarKeyEntry, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarKeyEntry {
        return AskarKeyEntry(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarKeyEntry) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarKeyEntry_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarKeyEntry {
    return try FfiConverterTypeAskarKeyEntry.lift(pointer)
}

public func FfiConverterTypeAskarKeyEntry_lower(_ value: AskarKeyEntry) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarKeyEntry.lower(value)
}

public protocol AskarLocalKeyProtocol {
    func aeadDecrypt(ciphertext: Data, tag: Data?, nonce: Data, aad: Data?) throws -> Data
    func aeadEncrypt(message: Data, nonce: Data?, aad: Data?) throws -> EncryptedBuffer
    func aeadPadding(msgLen: Int32) -> Int32
    func aeadParams() throws -> AeadParams
    func aeadRandomNonce() throws -> Data
    func algorithm() -> AskarKeyAlg
    func convertKey(alg: AskarKeyAlg) throws -> AskarLocalKey
    func signMessage(message: Data, sigType: String?) throws -> Data
    func toJwkPublic(alg: AskarKeyAlg?) throws -> String
    func toJwkSecret() throws -> Data
    func toJwkThumbprint(alg: AskarKeyAlg?) throws -> String
    func toJwkThumbprints() throws -> [String]
    func toKeyExchange(alg: AskarKeyAlg, pk: AskarLocalKey) throws -> AskarLocalKey
    func toPublicBytes() throws -> Data
    func toSecretBytes() throws -> Data
    func unwrapKey(alg: AskarKeyAlg, ciphertext: Data, tag: Data?, nonce: Data?) throws -> AskarLocalKey
    func verifySignature(message: Data, signature: Data, sigType: String?) throws -> Bool
    func wrapKey(key: AskarLocalKey, nonce: Data?) throws -> EncryptedBuffer
}

public class AskarLocalKey: AskarLocalKeyProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_askar_uniffi_fn_free_askarlocalkey(pointer, $0) }
    }

    public func aeadDecrypt(ciphertext: Data, tag: Data?, nonce: Data, aad: Data?) throws -> Data {
        return try FfiConverterData.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_aead_decrypt(self.pointer,
                                                                         FfiConverterData.lower(ciphertext),
                                                                         FfiConverterOptionData.lower(tag),
                                                                         FfiConverterData.lower(nonce),
                                                                         FfiConverterOptionData.lower(aad), $0)
            }
        )
    }

    public func aeadEncrypt(message: Data, nonce: Data?, aad: Data?) throws -> EncryptedBuffer {
        return try FfiConverterTypeEncryptedBuffer.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_aead_encrypt(self.pointer,
                                                                         FfiConverterData.lower(message),
                                                                         FfiConverterOptionData.lower(nonce),
                                                                         FfiConverterOptionData.lower(aad), $0)
            }
        )
    }

    public func aeadPadding(msgLen: Int32) -> Int32 {
        return try! FfiConverterInt32.lift(
            try!
                rustCall {
                    uniffi_askar_uniffi_fn_method_askarlocalkey_aead_padding(self.pointer,
                                                                             FfiConverterInt32.lower(msgLen), $0)
                }
        )
    }

    public func aeadParams() throws -> AeadParams {
        return try FfiConverterTypeAeadParams.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_aead_params(self.pointer, $0)
            }
        )
    }

    public func aeadRandomNonce() throws -> Data {
        return try FfiConverterData.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_aead_random_nonce(self.pointer, $0)
            }
        )
    }

    public func algorithm() -> AskarKeyAlg {
        return try! FfiConverterTypeAskarKeyAlg.lift(
            try!
                rustCall {
                    uniffi_askar_uniffi_fn_method_askarlocalkey_algorithm(self.pointer, $0)
                }
        )
    }

    public func convertKey(alg: AskarKeyAlg) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_convert_key(self.pointer,
                                                                        FfiConverterTypeAskarKeyAlg.lower(alg), $0)
            }
        )
    }

    public func signMessage(message: Data, sigType: String?) throws -> Data {
        return try FfiConverterData.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_sign_message(self.pointer,
                                                                         FfiConverterData.lower(message),
                                                                         FfiConverterOptionString.lower(sigType), $0)
            }
        )
    }

    public func toJwkPublic(alg: AskarKeyAlg?) throws -> String {
        return try FfiConverterString.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_to_jwk_public(self.pointer,
                                                                          FfiConverterOptionTypeAskarKeyAlg.lower(alg), $0)
            }
        )
    }

    public func toJwkSecret() throws -> Data {
        return try FfiConverterData.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_to_jwk_secret(self.pointer, $0)
            }
        )
    }

    public func toJwkThumbprint(alg: AskarKeyAlg?) throws -> String {
        return try FfiConverterString.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_to_jwk_thumbprint(self.pointer,
                                                                              FfiConverterOptionTypeAskarKeyAlg.lower(alg), $0)
            }
        )
    }

    public func toJwkThumbprints() throws -> [String] {
        return try FfiConverterSequenceString.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_to_jwk_thumbprints(self.pointer, $0)
            }
        )
    }

    public func toKeyExchange(alg: AskarKeyAlg, pk: AskarLocalKey) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_to_key_exchange(self.pointer,
                                                                            FfiConverterTypeAskarKeyAlg.lower(alg),
                                                                            FfiConverterTypeAskarLocalKey.lower(pk), $0)
            }
        )
    }

    public func toPublicBytes() throws -> Data {
        return try FfiConverterData.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_to_public_bytes(self.pointer, $0)
            }
        )
    }

    public func toSecretBytes() throws -> Data {
        return try FfiConverterData.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_to_secret_bytes(self.pointer, $0)
            }
        )
    }

    public func unwrapKey(alg: AskarKeyAlg, ciphertext: Data, tag: Data?, nonce: Data?) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_unwrap_key(self.pointer,
                                                                       FfiConverterTypeAskarKeyAlg.lower(alg),
                                                                       FfiConverterData.lower(ciphertext),
                                                                       FfiConverterOptionData.lower(tag),
                                                                       FfiConverterOptionData.lower(nonce), $0)
            }
        )
    }

    public func verifySignature(message: Data, signature: Data, sigType: String?) throws -> Bool {
        return try FfiConverterBool.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_verify_signature(self.pointer,
                                                                             FfiConverterData.lower(message),
                                                                             FfiConverterData.lower(signature),
                                                                             FfiConverterOptionString.lower(sigType), $0)
            }
        )
    }

    public func wrapKey(key: AskarLocalKey, nonce: Data?) throws -> EncryptedBuffer {
        return try FfiConverterTypeEncryptedBuffer.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarlocalkey_wrap_key(self.pointer,
                                                                     FfiConverterTypeAskarLocalKey.lower(key),
                                                                     FfiConverterOptionData.lower(nonce), $0)
            }
        )
    }
}

public struct FfiConverterTypeAskarLocalKey: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarLocalKey

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarLocalKey {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarLocalKey, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarLocalKey {
        return AskarLocalKey(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarLocalKey) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarLocalKey_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarLocalKey {
    return try FfiConverterTypeAskarLocalKey.lift(pointer)
}

public func FfiConverterTypeAskarLocalKey_lower(_ value: AskarLocalKey) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarLocalKey.lower(value)
}

public protocol AskarScanProtocol {
    func fetchAll() async throws -> [AskarEntry]
    func next() async throws -> [AskarEntry]?
}

public class AskarScan: AskarScanProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_askar_uniffi_fn_free_askarscan(pointer, $0) }
    }

    public func fetchAll() async throws -> [AskarEntry] {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarscan_fetch_all(
                    self.pointer
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_askar_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_askar_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeAskarEntry.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func next() async throws -> [AskarEntry]? {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarscan_next(
                    self.pointer
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_askar_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_askar_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionSequenceTypeAskarEntry.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }
}

public struct FfiConverterTypeAskarScan: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarScan

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarScan {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarScan, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarScan {
        return AskarScan(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarScan) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarScan_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarScan {
    return try FfiConverterTypeAskarScan.lift(pointer)
}

public func FfiConverterTypeAskarScan_lower(_ value: AskarScan) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarScan.lower(value)
}

public protocol AskarSessionProtocol {
    func close() async throws
    func count(category: String, tagFilter: String?) async throws -> Int64
    func fetch(category: String, name: String, forUpdate: Bool) async throws -> AskarEntry?
    func fetchAll(category: String, tagFilter: String?, limit: Int64?, forUpdate: Bool) async throws -> [AskarEntry]
    func fetchAllKeys(algorithm: String?, thumbprint: String?, tagFilter: String?, limit: Int64?, forUpdate: Bool) async throws -> [AskarKeyEntry]
    func fetchKey(name: String, forUpdate: Bool) async throws -> AskarKeyEntry?
    func insertKey(name: String, key: AskarLocalKey, metadata: String?, tags: String?, expiryMs: Int64?) async throws
    func removeAll(category: String, tagFilter: String?) async throws -> Int64
    func removeKey(name: String) async throws
    func update(operation: AskarEntryOperation, category: String, name: String, value: Data, tags: String?, expiryMs: Int64?) async throws
    func updateKey(name: String, metadata: String?, tags: String?, expiryMs: Int64?) async throws
}

public class AskarSession: AskarSessionProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_askar_uniffi_fn_free_askarsession(pointer, $0) }
    }

    public func close() async throws {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarsession_close(
                    self.pointer
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_void,
            completeFunc: ffi_askar_uniffi_rust_future_complete_void,
            freeFunc: ffi_askar_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func count(category: String, tagFilter: String?) async throws -> Int64 {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarsession_count(
                    self.pointer,
                    FfiConverterString.lower(category),
                    FfiConverterOptionString.lower(tagFilter)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_i64,
            completeFunc: ffi_askar_uniffi_rust_future_complete_i64,
            freeFunc: ffi_askar_uniffi_rust_future_free_i64,
            liftFunc: FfiConverterInt64.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func fetch(category: String, name: String, forUpdate: Bool) async throws -> AskarEntry? {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarsession_fetch(
                    self.pointer,
                    FfiConverterString.lower(category),
                    FfiConverterString.lower(name),
                    FfiConverterBool.lower(forUpdate)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_askar_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_askar_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeAskarEntry.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func fetchAll(category: String, tagFilter: String?, limit: Int64?, forUpdate: Bool) async throws -> [AskarEntry] {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarsession_fetch_all(
                    self.pointer,
                    FfiConverterString.lower(category),
                    FfiConverterOptionString.lower(tagFilter),
                    FfiConverterOptionInt64.lower(limit),
                    FfiConverterBool.lower(forUpdate)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_askar_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_askar_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeAskarEntry.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func fetchAllKeys(algorithm: String?, thumbprint: String?, tagFilter: String?, limit: Int64?, forUpdate: Bool) async throws -> [AskarKeyEntry] {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarsession_fetch_all_keys(
                    self.pointer,
                    FfiConverterOptionString.lower(algorithm),
                    FfiConverterOptionString.lower(thumbprint),
                    FfiConverterOptionString.lower(tagFilter),
                    FfiConverterOptionInt64.lower(limit),
                    FfiConverterBool.lower(forUpdate)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_askar_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_askar_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeAskarKeyEntry.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func fetchKey(name: String, forUpdate: Bool) async throws -> AskarKeyEntry? {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarsession_fetch_key(
                    self.pointer,
                    FfiConverterString.lower(name),
                    FfiConverterBool.lower(forUpdate)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_askar_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_askar_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeAskarKeyEntry.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func insertKey(name: String, key: AskarLocalKey, metadata: String?, tags: String?, expiryMs: Int64?) async throws {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarsession_insert_key(
                    self.pointer,
                    FfiConverterString.lower(name),
                    FfiConverterTypeAskarLocalKey.lower(key),
                    FfiConverterOptionString.lower(metadata),
                    FfiConverterOptionString.lower(tags),
                    FfiConverterOptionInt64.lower(expiryMs)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_void,
            completeFunc: ffi_askar_uniffi_rust_future_complete_void,
            freeFunc: ffi_askar_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func removeAll(category: String, tagFilter: String?) async throws -> Int64 {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarsession_remove_all(
                    self.pointer,
                    FfiConverterString.lower(category),
                    FfiConverterOptionString.lower(tagFilter)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_i64,
            completeFunc: ffi_askar_uniffi_rust_future_complete_i64,
            freeFunc: ffi_askar_uniffi_rust_future_free_i64,
            liftFunc: FfiConverterInt64.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func removeKey(name: String) async throws {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarsession_remove_key(
                    self.pointer,
                    FfiConverterString.lower(name)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_void,
            completeFunc: ffi_askar_uniffi_rust_future_complete_void,
            freeFunc: ffi_askar_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func update(operation: AskarEntryOperation, category: String, name: String, value: Data, tags: String?, expiryMs: Int64?) async throws {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarsession_update(
                    self.pointer,
                    FfiConverterTypeAskarEntryOperation.lower(operation),
                    FfiConverterString.lower(category),
                    FfiConverterString.lower(name),
                    FfiConverterData.lower(value),
                    FfiConverterOptionString.lower(tags),
                    FfiConverterOptionInt64.lower(expiryMs)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_void,
            completeFunc: ffi_askar_uniffi_rust_future_complete_void,
            freeFunc: ffi_askar_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func updateKey(name: String, metadata: String?, tags: String?, expiryMs: Int64?) async throws {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarsession_update_key(
                    self.pointer,
                    FfiConverterString.lower(name),
                    FfiConverterOptionString.lower(metadata),
                    FfiConverterOptionString.lower(tags),
                    FfiConverterOptionInt64.lower(expiryMs)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_void,
            completeFunc: ffi_askar_uniffi_rust_future_complete_void,
            freeFunc: ffi_askar_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }
}

public struct FfiConverterTypeAskarSession: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarSession

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarSession {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarSession, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarSession {
        return AskarSession(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarSession) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarSession_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarSession {
    return try FfiConverterTypeAskarSession.lift(pointer)
}

public func FfiConverterTypeAskarSession_lower(_ value: AskarSession) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarSession.lower(value)
}

public protocol AskarStoreProtocol {
    func close() async throws
    func createProfile(profile: String?) async throws -> String
    func getProfileName() async throws -> String
    func rekey(keyMethod: String?, passKey: String?) async throws
    func removeProfile(profile: String) async throws -> Bool
    func scan(profile: String?, category: String, tagFilter: String?, offset: Int64?, limit: Int64?) async throws -> AskarScan
    func session(profile: String?) async throws -> AskarSession
}

public class AskarStore: AskarStoreProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_askar_uniffi_fn_free_askarstore(pointer, $0) }
    }

    public func close() async throws {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarstore_close(
                    self.pointer
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_void,
            completeFunc: ffi_askar_uniffi_rust_future_complete_void,
            freeFunc: ffi_askar_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func createProfile(profile: String?) async throws -> String {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarstore_create_profile(
                    self.pointer,
                    FfiConverterOptionString.lower(profile)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_askar_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_askar_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func getProfileName() async throws -> String {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarstore_get_profile_name(
                    self.pointer
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_askar_uniffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_askar_uniffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func rekey(keyMethod: String?, passKey: String?) async throws {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarstore_rekey(
                    self.pointer,
                    FfiConverterOptionString.lower(keyMethod),
                    FfiConverterOptionString.lower(passKey)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_void,
            completeFunc: ffi_askar_uniffi_rust_future_complete_void,
            freeFunc: ffi_askar_uniffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func removeProfile(profile: String) async throws -> Bool {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarstore_remove_profile(
                    self.pointer,
                    FfiConverterString.lower(profile)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_i8,
            completeFunc: ffi_askar_uniffi_rust_future_complete_i8,
            freeFunc: ffi_askar_uniffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func scan(profile: String?, category: String, tagFilter: String?, offset: Int64?, limit: Int64?) async throws -> AskarScan {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarstore_scan(
                    self.pointer,
                    FfiConverterOptionString.lower(profile),
                    FfiConverterString.lower(category),
                    FfiConverterOptionString.lower(tagFilter),
                    FfiConverterOptionInt64.lower(offset),
                    FfiConverterOptionInt64.lower(limit)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_pointer,
            completeFunc: ffi_askar_uniffi_rust_future_complete_pointer,
            freeFunc: ffi_askar_uniffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeAskarScan.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func session(profile: String?) async throws -> AskarSession {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarstore_session(
                    self.pointer,
                    FfiConverterOptionString.lower(profile)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_pointer,
            completeFunc: ffi_askar_uniffi_rust_future_complete_pointer,
            freeFunc: ffi_askar_uniffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeAskarSession.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }
}

public struct FfiConverterTypeAskarStore: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarStore

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarStore {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarStore, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarStore {
        return AskarStore(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarStore) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarStore_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarStore {
    return try FfiConverterTypeAskarStore.lift(pointer)
}

public func FfiConverterTypeAskarStore_lower(_ value: AskarStore) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarStore.lower(value)
}

public protocol AskarStoreManagerProtocol {
    func generateRawStoreKey(seed: String?) throws -> String
    func open(specUri: String, keyMethod: String?, passKey: String?, profile: String?) async throws -> AskarStore
    func provision(specUri: String, keyMethod: String?, passKey: String?, profile: String?, recreate: Bool) async throws -> AskarStore
    func remove(specUri: String) async throws -> Bool
}

public class AskarStoreManager: AskarStoreManagerProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_askar_uniffi_fn_constructor_askarstoremanager_new($0)
        })
    }

    deinit {
        try! rustCall { uniffi_askar_uniffi_fn_free_askarstoremanager(pointer, $0) }
    }

    public func generateRawStoreKey(seed: String?) throws -> String {
        return try FfiConverterString.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_askarstoremanager_generate_raw_store_key(self.pointer,
                                                                                       FfiConverterOptionString.lower(seed), $0)
            }
        )
    }

    public func open(specUri: String, keyMethod: String?, passKey: String?, profile: String?) async throws -> AskarStore {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarstoremanager_open(
                    self.pointer,
                    FfiConverterString.lower(specUri),
                    FfiConverterOptionString.lower(keyMethod),
                    FfiConverterOptionString.lower(passKey),
                    FfiConverterOptionString.lower(profile)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_pointer,
            completeFunc: ffi_askar_uniffi_rust_future_complete_pointer,
            freeFunc: ffi_askar_uniffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeAskarStore.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func provision(specUri: String, keyMethod: String?, passKey: String?, profile: String?, recreate: Bool) async throws -> AskarStore {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarstoremanager_provision(
                    self.pointer,
                    FfiConverterString.lower(specUri),
                    FfiConverterOptionString.lower(keyMethod),
                    FfiConverterOptionString.lower(passKey),
                    FfiConverterOptionString.lower(profile),
                    FfiConverterBool.lower(recreate)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_pointer,
            completeFunc: ffi_askar_uniffi_rust_future_complete_pointer,
            freeFunc: ffi_askar_uniffi_rust_future_free_pointer,
            liftFunc: FfiConverterTypeAskarStore.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }

    public func remove(specUri: String) async throws -> Bool {
        return try await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_askar_uniffi_fn_method_askarstoremanager_remove(
                    self.pointer,
                    FfiConverterString.lower(specUri)
                )
            },
            pollFunc: ffi_askar_uniffi_rust_future_poll_i8,
            completeFunc: ffi_askar_uniffi_rust_future_complete_i8,
            freeFunc: ffi_askar_uniffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeErrorCode.lift
        )
    }
}

public struct FfiConverterTypeAskarStoreManager: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = AskarStoreManager

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarStoreManager {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: AskarStoreManager, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarStoreManager {
        return AskarStoreManager(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: AskarStoreManager) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeAskarStoreManager_lift(_ pointer: UnsafeMutableRawPointer) throws -> AskarStoreManager {
    return try FfiConverterTypeAskarStoreManager.lift(pointer)
}

public func FfiConverterTypeAskarStoreManager_lower(_ value: AskarStoreManager) -> UnsafeMutableRawPointer {
    return FfiConverterTypeAskarStoreManager.lower(value)
}

public protocol EncryptedBufferProtocol {
    func ciphertext() -> Data
    func ciphertextTag() -> Data
    func nonce() -> Data
    func tag() -> Data
}

public class EncryptedBuffer: EncryptedBufferProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    deinit {
        try! rustCall { uniffi_askar_uniffi_fn_free_encryptedbuffer(pointer, $0) }
    }

    public func ciphertext() -> Data {
        return try! FfiConverterData.lift(
            try!
                rustCall {
                    uniffi_askar_uniffi_fn_method_encryptedbuffer_ciphertext(self.pointer, $0)
                }
        )
    }

    public func ciphertextTag() -> Data {
        return try! FfiConverterData.lift(
            try!
                rustCall {
                    uniffi_askar_uniffi_fn_method_encryptedbuffer_ciphertext_tag(self.pointer, $0)
                }
        )
    }

    public func nonce() -> Data {
        return try! FfiConverterData.lift(
            try!
                rustCall {
                    uniffi_askar_uniffi_fn_method_encryptedbuffer_nonce(self.pointer, $0)
                }
        )
    }

    public func tag() -> Data {
        return try! FfiConverterData.lift(
            try!
                rustCall {
                    uniffi_askar_uniffi_fn_method_encryptedbuffer_tag(self.pointer, $0)
                }
        )
    }
}

public struct FfiConverterTypeEncryptedBuffer: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = EncryptedBuffer

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedBuffer {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: EncryptedBuffer, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> EncryptedBuffer {
        return EncryptedBuffer(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: EncryptedBuffer) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeEncryptedBuffer_lift(_ pointer: UnsafeMutableRawPointer) throws -> EncryptedBuffer {
    return try FfiConverterTypeEncryptedBuffer.lift(pointer)
}

public func FfiConverterTypeEncryptedBuffer_lower(_ value: EncryptedBuffer) -> UnsafeMutableRawPointer {
    return FfiConverterTypeEncryptedBuffer.lower(value)
}

public protocol LocalKeyFactoryProtocol {
    func fromJwk(jwk: String) throws -> AskarLocalKey
    func fromJwkSlice(jwk: Data) throws -> AskarLocalKey
    func fromPublicBytes(alg: AskarKeyAlg, bytes: Data) throws -> AskarLocalKey
    func fromSecretBytes(alg: AskarKeyAlg, bytes: Data) throws -> AskarLocalKey
    func fromSeed(alg: AskarKeyAlg, seed: Data, method: SeedMethod?) throws -> AskarLocalKey
    func generate(alg: AskarKeyAlg, ephemeral: Bool) throws -> AskarLocalKey
}

public class LocalKeyFactory: LocalKeyFactoryProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    public convenience init() {
        self.init(unsafeFromRawPointer: try! rustCall {
            uniffi_askar_uniffi_fn_constructor_localkeyfactory_new($0)
        })
    }

    deinit {
        try! rustCall { uniffi_askar_uniffi_fn_free_localkeyfactory(pointer, $0) }
    }

    public func fromJwk(jwk: String) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_localkeyfactory_from_jwk(self.pointer,
                                                                       FfiConverterString.lower(jwk), $0)
            }
        )
    }

    public func fromJwkSlice(jwk: Data) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_localkeyfactory_from_jwk_slice(self.pointer,
                                                                             FfiConverterData.lower(jwk), $0)
            }
        )
    }

    public func fromPublicBytes(alg: AskarKeyAlg, bytes: Data) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_localkeyfactory_from_public_bytes(self.pointer,
                                                                                FfiConverterTypeAskarKeyAlg.lower(alg),
                                                                                FfiConverterData.lower(bytes), $0)
            }
        )
    }

    public func fromSecretBytes(alg: AskarKeyAlg, bytes: Data) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_localkeyfactory_from_secret_bytes(self.pointer,
                                                                                FfiConverterTypeAskarKeyAlg.lower(alg),
                                                                                FfiConverterData.lower(bytes), $0)
            }
        )
    }

    public func fromSeed(alg: AskarKeyAlg, seed: Data, method: SeedMethod?) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_localkeyfactory_from_seed(self.pointer,
                                                                        FfiConverterTypeAskarKeyAlg.lower(alg),
                                                                        FfiConverterData.lower(seed),
                                                                        FfiConverterOptionTypeSeedMethod.lower(method), $0)
            }
        )
    }

    public func generate(alg: AskarKeyAlg, ephemeral: Bool) throws -> AskarLocalKey {
        return try FfiConverterTypeAskarLocalKey.lift(
            rustCallWithError(FfiConverterTypeErrorCode.lift) {
                uniffi_askar_uniffi_fn_method_localkeyfactory_generate(self.pointer,
                                                                       FfiConverterTypeAskarKeyAlg.lower(alg),
                                                                       FfiConverterBool.lower(ephemeral), $0)
            }
        )
    }
}

public struct FfiConverterTypeLocalKeyFactory: FfiConverter {
    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = LocalKeyFactory

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalKeyFactory {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if ptr == nil {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: LocalKeyFactory, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> LocalKeyFactory {
        return LocalKeyFactory(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: LocalKeyFactory) -> UnsafeMutableRawPointer {
        return value.pointer
    }
}

public func FfiConverterTypeLocalKeyFactory_lift(_ pointer: UnsafeMutableRawPointer) throws -> LocalKeyFactory {
    return try FfiConverterTypeLocalKeyFactory.lift(pointer)
}

public func FfiConverterTypeLocalKeyFactory_lower(_ value: LocalKeyFactory) -> UnsafeMutableRawPointer {
    return FfiConverterTypeLocalKeyFactory.lower(value)
}

public struct AeadParams {
    public var nonceLength: Int32
    public var tagLength: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(nonceLength: Int32, tagLength: Int32) {
        self.nonceLength = nonceLength
        self.tagLength = tagLength
    }
}

extension AeadParams: Equatable, Hashable {
    public static func == (lhs: AeadParams, rhs: AeadParams) -> Bool {
        if lhs.nonceLength != rhs.nonceLength {
            return false
        }
        if lhs.tagLength != rhs.tagLength {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(nonceLength)
        hasher.combine(tagLength)
    }
}

public struct FfiConverterTypeAeadParams: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AeadParams {
        return try AeadParams(
            nonceLength: FfiConverterInt32.read(from: &buf),
            tagLength: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: AeadParams, into buf: inout [UInt8]) {
        FfiConverterInt32.write(value.nonceLength, into: &buf)
        FfiConverterInt32.write(value.tagLength, into: &buf)
    }
}

public func FfiConverterTypeAeadParams_lift(_ buf: RustBuffer) throws -> AeadParams {
    return try FfiConverterTypeAeadParams.lift(buf)
}

public func FfiConverterTypeAeadParams_lower(_ value: AeadParams) -> RustBuffer {
    return FfiConverterTypeAeadParams.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AskarEntryOperation {
    case insert
    case replace
    case remove
}

public struct FfiConverterTypeAskarEntryOperation: FfiConverterRustBuffer {
    typealias SwiftType = AskarEntryOperation

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarEntryOperation {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .insert

        case 2: return .replace

        case 3: return .remove

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AskarEntryOperation, into buf: inout [UInt8]) {
        switch value {
        case .insert:
            writeInt(&buf, Int32(1))

        case .replace:
            writeInt(&buf, Int32(2))

        case .remove:
            writeInt(&buf, Int32(3))
        }
    }
}

public func FfiConverterTypeAskarEntryOperation_lift(_ buf: RustBuffer) throws -> AskarEntryOperation {
    return try FfiConverterTypeAskarEntryOperation.lift(buf)
}

public func FfiConverterTypeAskarEntryOperation_lower(_ value: AskarEntryOperation) -> RustBuffer {
    return FfiConverterTypeAskarEntryOperation.lower(value)
}

extension AskarEntryOperation: Equatable, Hashable {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum AskarKeyAlg {
    case a128Gcm
    case a256Gcm
    case a128CbcHs256
    case a256CbcHs512
    case a128Kw
    case a256Kw
    case bls12381g1
    case bls12381g2
    case bls12381g1g2
    case c20p
    case xc20p
    case ed25519
    case x25519
    case k256
    case p256
    case p384
}

public struct FfiConverterTypeAskarKeyAlg: FfiConverterRustBuffer {
    typealias SwiftType = AskarKeyAlg

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AskarKeyAlg {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .a128Gcm

        case 2: return .a256Gcm

        case 3: return .a128CbcHs256

        case 4: return .a256CbcHs512

        case 5: return .a128Kw

        case 6: return .a256Kw

        case 7: return .bls12381g1

        case 8: return .bls12381g2

        case 9: return .bls12381g1g2

        case 10: return .c20p

        case 11: return .xc20p

        case 12: return .ed25519

        case 13: return .x25519

        case 14: return .k256

        case 15: return .p256

        case 16: return .p384

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AskarKeyAlg, into buf: inout [UInt8]) {
        switch value {
        case .a128Gcm:
            writeInt(&buf, Int32(1))

        case .a256Gcm:
            writeInt(&buf, Int32(2))

        case .a128CbcHs256:
            writeInt(&buf, Int32(3))

        case .a256CbcHs512:
            writeInt(&buf, Int32(4))

        case .a128Kw:
            writeInt(&buf, Int32(5))

        case .a256Kw:
            writeInt(&buf, Int32(6))

        case .bls12381g1:
            writeInt(&buf, Int32(7))

        case .bls12381g2:
            writeInt(&buf, Int32(8))

        case .bls12381g1g2:
            writeInt(&buf, Int32(9))

        case .c20p:
            writeInt(&buf, Int32(10))

        case .xc20p:
            writeInt(&buf, Int32(11))

        case .ed25519:
            writeInt(&buf, Int32(12))

        case .x25519:
            writeInt(&buf, Int32(13))

        case .k256:
            writeInt(&buf, Int32(14))

        case .p256:
            writeInt(&buf, Int32(15))

        case .p384:
            writeInt(&buf, Int32(16))
        }
    }
}

public func FfiConverterTypeAskarKeyAlg_lift(_ buf: RustBuffer) throws -> AskarKeyAlg {
    return try FfiConverterTypeAskarKeyAlg.lift(buf)
}

public func FfiConverterTypeAskarKeyAlg_lower(_ value: AskarKeyAlg) -> RustBuffer {
    return FfiConverterTypeAskarKeyAlg.lower(value)
}

extension AskarKeyAlg: Equatable, Hashable {}

public enum ErrorCode {
    case Backend(message: String)
    case Busy(message: String)
    case Duplicate(message: String)
    case Encryption(message: String)
    case Input(message: String)
    case NotFound(message: String)
    case Unexpected(message: String)
    case Unsupported(message: String)
    case Custom(message: String)

    fileprivate static func uniffiErrorHandler(_ error: RustBuffer) throws -> Error {
        return try FfiConverterTypeErrorCode.lift(error)
    }
}

public struct FfiConverterTypeErrorCode: FfiConverterRustBuffer {
    typealias SwiftType = ErrorCode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ErrorCode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return try .Backend(
                message: FfiConverterString.read(from: &buf)
            )
        case 2: return try .Busy(
                message: FfiConverterString.read(from: &buf)
            )
        case 3: return try .Duplicate(
                message: FfiConverterString.read(from: &buf)
            )
        case 4: return try .Encryption(
                message: FfiConverterString.read(from: &buf)
            )
        case 5: return try .Input(
                message: FfiConverterString.read(from: &buf)
            )
        case 6: return try .NotFound(
                message: FfiConverterString.read(from: &buf)
            )
        case 7: return try .Unexpected(
                message: FfiConverterString.read(from: &buf)
            )
        case 8: return try .Unsupported(
                message: FfiConverterString.read(from: &buf)
            )
        case 9: return try .Custom(
                message: FfiConverterString.read(from: &buf)
            )

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ErrorCode, into buf: inout [UInt8]) {
        switch value {
        case let .Backend(message):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(message, into: &buf)

        case let .Busy(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)

        case let .Duplicate(message):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(message, into: &buf)

        case let .Encryption(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)

        case let .Input(message):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(message, into: &buf)

        case let .NotFound(message):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(message, into: &buf)

        case let .Unexpected(message):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(message, into: &buf)

        case let .Unsupported(message):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(message, into: &buf)

        case let .Custom(message):
            writeInt(&buf, Int32(9))
            FfiConverterString.write(message, into: &buf)
        }
    }
}

extension ErrorCode: Equatable, Hashable {}

extension ErrorCode: Error {}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
public enum SeedMethod {
    case blsKeyGen
}

public struct FfiConverterTypeSeedMethod: FfiConverterRustBuffer {
    typealias SwiftType = SeedMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SeedMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        case 1: return .blsKeyGen

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SeedMethod, into buf: inout [UInt8]) {
        switch value {
        case .blsKeyGen:
            writeInt(&buf, Int32(1))
        }
    }
}

public func FfiConverterTypeSeedMethod_lift(_ buf: RustBuffer) throws -> SeedMethod {
    return try FfiConverterTypeSeedMethod.lift(buf)
}

public func FfiConverterTypeSeedMethod_lower(_ value: SeedMethod) -> RustBuffer {
    return FfiConverterTypeSeedMethod.lower(value)
}

extension SeedMethod: Equatable, Hashable {}

private struct FfiConverterOptionInt64: FfiConverterRustBuffer {
    typealias SwiftType = Int64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionData: FfiConverterRustBuffer {
    typealias SwiftType = Data?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeAskarEntry: FfiConverterRustBuffer {
    typealias SwiftType = AskarEntry?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAskarEntry.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAskarEntry.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeAskarKeyEntry: FfiConverterRustBuffer {
    typealias SwiftType = AskarKeyEntry?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAskarKeyEntry.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAskarKeyEntry.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeAskarKeyAlg: FfiConverterRustBuffer {
    typealias SwiftType = AskarKeyAlg?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAskarKeyAlg.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAskarKeyAlg.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionTypeSeedMethod: FfiConverterRustBuffer {
    typealias SwiftType = SeedMethod?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSeedMethod.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSeedMethod.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterOptionSequenceTypeAskarEntry: FfiConverterRustBuffer {
    typealias SwiftType = [AskarEntry]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAskarEntry.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAskarEntry.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

private struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAskarEntry: FfiConverterRustBuffer {
    typealias SwiftType = [AskarEntry]

    public static func write(_ value: [AskarEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAskarEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AskarEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [AskarEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAskarEntry.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterSequenceTypeAskarKeyEntry: FfiConverterRustBuffer {
    typealias SwiftType = [AskarKeyEntry]

    public static func write(_ value: [AskarKeyEntry], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAskarKeyEntry.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AskarKeyEntry] {
        let len: Int32 = try readInt(&buf)
        var seq = [AskarKeyEntry]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            try seq.append(FfiConverterTypeAskarKeyEntry.read(from: &buf))
        }
        return seq
    }
}

private struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_MAYBE_READY: Int8 = 1

private func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UnsafeMutableRawPointer,
    pollFunc: (UnsafeMutableRawPointer, UnsafeMutableRawPointer) -> Void,
    completeFunc: (UnsafeMutableRawPointer, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UnsafeMutableRawPointer) -> Void,
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Error)?
) async throws -> T {
    // Make sure to call uniffiEnsureInitialized() since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(rustFuture, ContinuationHolder($0).toOpaque())
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
private func uniffiFutureContinuationCallback(ptr: UnsafeMutableRawPointer, pollResult: Int8) {
    ContinuationHolder.fromOpaque(ptr).resume(pollResult)
}

// Wraps UnsafeContinuation in a class so that we can use reference counting when passing it across
// the FFI
private class ContinuationHolder {
    let continuation: UnsafeContinuation<Int8, Never>

    init(_ continuation: UnsafeContinuation<Int8, Never>) {
        self.continuation = continuation
    }

    func resume(_ pollResult: Int8) {
        continuation.resume(returning: pollResult)
    }

    func toOpaque() -> UnsafeMutableRawPointer {
        return Unmanaged<ContinuationHolder>.passRetained(self).toOpaque()
    }

    static func fromOpaque(_ ptr: UnsafeRawPointer) -> ContinuationHolder {
        return Unmanaged<ContinuationHolder>.fromOpaque(ptr).takeRetainedValue()
    }
}

private func uniffiInitContinuationCallback() {
    ffi_askar_uniffi_rust_future_continuation_callback_set(uniffiFutureContinuationCallback)
}

public func setDefaultLogger() throws {
    try rustCallWithError(FfiConverterTypeErrorCode.lift) {
        uniffi_askar_uniffi_fn_func_set_default_logger($0)
    }
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}

// Use a global variables to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 24
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_askar_uniffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if uniffi_askar_uniffi_checksum_func_set_default_logger() != 54242 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarcrypto_box_open() != 34152 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarcrypto_box_seal() != 34783 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarcrypto_box_seal_open() != 64727 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarcrypto_crypto_box() != 30458 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarcrypto_random_nonce() != 57381 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarecdh1pu_decrypt_direct() != 6517 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarecdh1pu_derive_key() != 22190 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarecdh1pu_encrypt_direct() != 19758 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarecdh1pu_receiver_unwrap_key() != 10626 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarecdh1pu_sender_wrap_key() != 58698 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarecdhes_decrypt_direct() != 39011 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarecdhes_derive_key() != 59480 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarecdhes_encrypt_direct() != 39370 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarecdhes_receiver_unwrap_key() != 18215 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarecdhes_sender_wrap_key() != 57916 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarentry_category() != 51508 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarentry_name() != 5289 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarentry_tags() != 19151 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarentry_value() != 43058 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarkeyentry_algorithm() != 19756 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarkeyentry_is_local() != 31577 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarkeyentry_load_local_key() != 29926 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarkeyentry_metadata() != 40559 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarkeyentry_name() != 1820 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarkeyentry_tags() != 16950 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_aead_decrypt() != 12105 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_aead_encrypt() != 20202 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_aead_padding() != 26930 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_aead_params() != 55632 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_aead_random_nonce() != 24326 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_algorithm() != 54915 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_convert_key() != 46312 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_sign_message() != 24515 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_to_jwk_public() != 55614 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_to_jwk_secret() != 13845 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_to_jwk_thumbprint() != 45533 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_to_jwk_thumbprints() != 29630 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_to_key_exchange() != 10314 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_to_public_bytes() != 27474 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_to_secret_bytes() != 17828 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_unwrap_key() != 11323 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_verify_signature() != 32684 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarlocalkey_wrap_key() != 32867 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarscan_fetch_all() != 47469 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarscan_next() != 53585 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarsession_close() != 14885 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarsession_count() != 59414 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarsession_fetch() != 31145 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarsession_fetch_all() != 44370 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarsession_fetch_all_keys() != 4295 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarsession_fetch_key() != 4957 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarsession_insert_key() != 10599 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarsession_remove_all() != 52405 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarsession_remove_key() != 32196 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarsession_update() != 10635 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarsession_update_key() != 22442 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarstore_close() != 51881 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarstore_create_profile() != 51222 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarstore_get_profile_name() != 9253 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarstore_rekey() != 12546 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarstore_remove_profile() != 23646 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarstore_scan() != 13289 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarstore_session() != 8649 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarstoremanager_generate_raw_store_key() != 8565 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarstoremanager_open() != 236 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarstoremanager_provision() != 38933 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_askarstoremanager_remove() != 39852 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_encryptedbuffer_ciphertext() != 61503 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_encryptedbuffer_ciphertext_tag() != 41049 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_encryptedbuffer_nonce() != 34071 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_encryptedbuffer_tag() != 57276 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_localkeyfactory_from_jwk() != 2194 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_localkeyfactory_from_jwk_slice() != 29453 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_localkeyfactory_from_public_bytes() != 156 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_localkeyfactory_from_secret_bytes() != 55775 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_localkeyfactory_from_seed() != 29414 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_method_localkeyfactory_generate() != 25046 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_constructor_askarcrypto_new() != 4039 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_constructor_askarecdh1pu_new() != 11144 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_constructor_askarecdhes_new() != 52466 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_constructor_askarstoremanager_new() != 39894 {
        return InitializationResult.apiChecksumMismatch
    }
    if uniffi_askar_uniffi_checksum_constructor_localkeyfactory_new() != 21843 {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiInitContinuationCallback()
    return InitializationResult.ok
}

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}
